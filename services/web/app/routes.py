"""
This script contains endpoints definitions
"""
import sys
from flask import render_template, redirect, request, Response
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from . import app, db
from flask_httpauth import HTTPBasicAuth
from werkzeug.security import generate_password_hash, check_password_hash
from config import Config
import base64
from werkzeug.serving import WSGIRequestHandler

import logging
from logging.handlers import RotatingFileHandler
from time import strftime

app.config.from_object(Config)


limiter = Limiter(app, default_limits=app.config["RATE_LIMITS"], key_func=get_remote_address)
# limiter.init_app(app) 


auth = HTTPBasicAuth()
users = {
    "admin": generate_password_hash(Config.PASSWORD)
}

# auth
@auth.verify_password
def verify_password(username, password):
    if username in users and \
            check_password_hash(users.get(username), password):
        return username


# logging
handler = RotatingFileHandler('app.log', maxBytes=100000, backupCount=3)
logger = logging.getLogger('tdm')
logger.setLevel(logging.ERROR)
logger.addHandler(handler)

@app.after_request
def after_request(response):
    # don't log requests to log endpoint or favicon
    if request.full_path == '/api/actions/log?' or request.full_path == '/favicon.ico?':
        return response

    timestamp = strftime('[%Y-%b-%d %H:%M]')
    logger.error('%s %s %s %s %s %s', timestamp, request.remote_addr, request.method, request.scheme, request.full_path, response.status)
    return response


@app.route('/api/actions/log', methods = ['GET', 'POST'])
@auth.login_required
def read_log():
    if request.method == "GET":
        return Response(open("app.log", "r").read().replace('\n', '<br>'))
    if request.method == "POST":
        open('app.log', 'w').truncate(0)
        return Response("Log cleared")



# routes
@app.route('/', methods = ['GET', 'POST'], defaults={'path': ''})
@auth.login_required
def exploit_data(path):
    if request.method == "GET":
        return render_template("index.html", exploit_path="/exploit", exploit_header="HTTP/1.1 200\r\nContent-Type: text/plain; charset=utf-8", exploit_body="Hello World!", exploit_body_base64Encoded='unchecked')

    if request.method == "POST":
        # save data
        print(request.form)
        protocol = 'https' if 'exploit-https' in request.form.keys() else 'http'
        formAction = request.form['formAction']
        if formAction == "STORE" or formAction == "View Exploit":
            request_path = base64.b64encode(request.form['exploit-file'].encode()).decode()
            request_headers = base64.b64encode(request.form['exploit-header'].encode()).decode()
            request_body = base64.b64encode(request.form['exploit-body'].encode()).decode()
            request_body_base64_encoded = 'checked' if 'exploit-body-base64encoded' in request.form else 'unchcked'

            db_query = f"INSERT OR REPLACE INTO exploits (path, header, body, body_base64encoded) VALUES('{request_path}', '{request_headers}' , '{request_body}', '{request_body_base64_encoded}');"
            db.engine.execute(db_query)

            # get newly saved data
            db_query = f"SELECT path, header, body, body_base64encoded FROM exploits WHERE path = '{request_path}'"
            res = db.engine.execute(db_query)
            print("INSERTED")
            data = res.fetchall()
            print(data)
            response_path = base64.b64decode(data[0][0].encode()).decode()
            response_headers = base64.b64decode(data[0][1].encode()).decode()
            response_data = base64.b64decode(data[0][2].encode()).decode()
            response_data_base64Encoded = data[0][3]
            print("Value retrieved: " + response_data_base64Encoded)

            # redirect if viewing exploit
            if formAction == "View Exploit":
                return redirect(f"{protocol}://{request.headers['Host']}{request.form['exploit-file']}", 302)
            return render_template("index.html", exploit_path=response_path, exploit_header=response_headers, exploit_body=response_data, exploit_body_base64Encoded=response_data_base64Encoded)

        elif formAction == "DELETE ALL RECORDS":
            db_query = f"DELETE FROM exploits"
            res = db.engine.execute(db_query)
            return redirect("/", 302)
    return render_template("index.html", exploit_path="/exploit", exploit_header="HTTP/1.1 200\r\nContent-Type: text/plain; charset=utf-8", exploit_body="Hello World!", exploit_body_base64Encoded='unchecked')



@app.route('/<path:path>', methods = ['GET'])
def index(path):
    print(f"path: {path}")
    request_path = base64.b64encode(("/" + path).encode()).decode()

    # get data from db + surface
    db_query = f"SELECT path, header, body, body_base64encoded FROM exploits WHERE path = '{request_path}';"
    res = db.engine.execute(db_query)
    data = res.fetchall()
    if data:
        response_headers = base64.b64decode(data[0][1].encode()).decode().split('\r\n')
        response_data = base64.b64decode(data[0][2].encode()).decode()
        response_data_base64Encoded = data[0][3]
        response_data = base64.b64decode(response_data.encode()) if response_data_base64Encoded == 'checked' else response_data

        # Create response
        response_protocol = response_headers[0].split(' ')[0] 
        WSGIRequestHandler.protocol_version = response_protocol

        response_code = response_headers[0].split(' ')[1]
        
        # resp = Response(response_data, status=response_code)
        resp = Response(response_data, status=response_code)
        resp.autocorrect_location_header = False
        # set headers
        for header in response_headers:
            if ':' in header:
                resp.headers[header.split(':')[0]] = ":".join(header.split(':')[1:])
        return resp
    return Response("default response")

    